// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: risk_protocal.proto

#ifndef PROTOBUF_risk_5fprotocal_2eproto__INCLUDED
#define PROTOBUF_risk_5fprotocal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace risk {
class cffex_margin_field;
class cffex_margin_fieldDefaultTypeInternal;
extern cffex_margin_fieldDefaultTypeInternal _cffex_margin_field_default_instance_;
class czce_margin_field;
class czce_margin_fieldDefaultTypeInternal;
extern czce_margin_fieldDefaultTypeInternal _czce_margin_field_default_instance_;
class dce_margin_field;
class dce_margin_fieldDefaultTypeInternal;
extern dce_margin_fieldDefaultTypeInternal _dce_margin_field_default_instance_;
class error_info;
class error_infoDefaultTypeInternal;
extern error_infoDefaultTypeInternal _error_info_default_instance_;
class req_investor_list;
class req_investor_listDefaultTypeInternal;
extern req_investor_listDefaultTypeInternal _req_investor_list_default_instance_;
class req_risker_login;
class req_risker_loginDefaultTypeInternal;
extern req_risker_loginDefaultTypeInternal _req_risker_login_default_instance_;
class rsp_investor_list;
class rsp_investor_listDefaultTypeInternal;
extern rsp_investor_listDefaultTypeInternal _rsp_investor_list_default_instance_;
class rsp_risker_login;
class rsp_risker_loginDefaultTypeInternal;
extern rsp_risker_loginDefaultTypeInternal _rsp_risker_login_default_instance_;
class rtn_margin_field;
class rtn_margin_fieldDefaultTypeInternal;
extern rtn_margin_fieldDefaultTypeInternal _rtn_margin_field_default_instance_;
class shfe_margin_field;
class shfe_margin_fieldDefaultTypeInternal;
extern shfe_margin_fieldDefaultTypeInternal _shfe_margin_field_default_instance_;
class subscribe_margin;
class subscribe_marginDefaultTypeInternal;
extern subscribe_marginDefaultTypeInternal _subscribe_margin_default_instance_;
class unsubscribe_margin;
class unsubscribe_marginDefaultTypeInternal;
extern unsubscribe_marginDefaultTypeInternal _unsubscribe_margin_default_instance_;
}  // namespace risk

namespace risk {

namespace protobuf_risk_5fprotocal_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_risk_5fprotocal_2eproto

// ===================================================================

class error_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.error_info) */ {
 public:
  error_info();
  virtual ~error_info();

  error_info(const error_info& from);

  inline error_info& operator=(const error_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  error_info(error_info&& from) noexcept
    : error_info() {
    *this = ::std::move(from);
  }

  inline error_info& operator=(error_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const error_info& default_instance();

  static inline const error_info* internal_default_instance() {
    return reinterpret_cast<const error_info*>(
               &_error_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(error_info* other);
  friend void swap(error_info& a, error_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline error_info* New() const PROTOBUF_FINAL { return New(NULL); }

  error_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const error_info& from);
  void MergeFrom(const error_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(error_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string errormsg = 2;
  void clear_errormsg();
  static const int kErrormsgFieldNumber = 2;
  const ::std::string& errormsg() const;
  void set_errormsg(const ::std::string& value);
  #if LANG_CXX11
  void set_errormsg(::std::string&& value);
  #endif
  void set_errormsg(const char* value);
  void set_errormsg(const char* value, size_t size);
  ::std::string* mutable_errormsg();
  ::std::string* release_errormsg();
  void set_allocated_errormsg(::std::string* errormsg);

  // sint32 errorid = 1;
  void clear_errorid();
  static const int kErroridFieldNumber = 1;
  ::google::protobuf::int32 errorid() const;
  void set_errorid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.error_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr errormsg_;
  ::google::protobuf::int32 errorid_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_risker_login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_risker_login) */ {
 public:
  req_risker_login();
  virtual ~req_risker_login();

  req_risker_login(const req_risker_login& from);

  inline req_risker_login& operator=(const req_risker_login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_risker_login(req_risker_login&& from) noexcept
    : req_risker_login() {
    *this = ::std::move(from);
  }

  inline req_risker_login& operator=(req_risker_login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_risker_login& default_instance();

  static inline const req_risker_login* internal_default_instance() {
    return reinterpret_cast<const req_risker_login*>(
               &_req_risker_login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(req_risker_login* other);
  friend void swap(req_risker_login& a, req_risker_login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_risker_login* New() const PROTOBUF_FINAL { return New(NULL); }

  req_risker_login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_risker_login& from);
  void MergeFrom(const req_risker_login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_risker_login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string riskerid = 1;
  void clear_riskerid();
  static const int kRiskeridFieldNumber = 1;
  const ::std::string& riskerid() const;
  void set_riskerid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskerid(::std::string&& value);
  #endif
  void set_riskerid(const char* value);
  void set_riskerid(const char* value, size_t size);
  ::std::string* mutable_riskerid();
  ::std::string* release_riskerid();
  void set_allocated_riskerid(::std::string* riskerid);

  // string password = 2;
  void clear_password();
  static const int kPasswordFieldNumber = 2;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:risk.req_risker_login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr riskerid_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rsp_risker_login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.rsp_risker_login) */ {
 public:
  rsp_risker_login();
  virtual ~rsp_risker_login();

  rsp_risker_login(const rsp_risker_login& from);

  inline rsp_risker_login& operator=(const rsp_risker_login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rsp_risker_login(rsp_risker_login&& from) noexcept
    : rsp_risker_login() {
    *this = ::std::move(from);
  }

  inline rsp_risker_login& operator=(rsp_risker_login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const rsp_risker_login& default_instance();

  static inline const rsp_risker_login* internal_default_instance() {
    return reinterpret_cast<const rsp_risker_login*>(
               &_rsp_risker_login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(rsp_risker_login* other);
  friend void swap(rsp_risker_login& a, rsp_risker_login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rsp_risker_login* New() const PROTOBUF_FINAL { return New(NULL); }

  rsp_risker_login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const rsp_risker_login& from);
  void MergeFrom(const rsp_risker_login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(rsp_risker_login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .risk.error_info info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::risk::error_info& info() const;
  ::risk::error_info* mutable_info();
  ::risk::error_info* release_info();
  void set_allocated_info(::risk::error_info* info);

  // @@protoc_insertion_point(class_scope:risk.rsp_risker_login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::risk::error_info* info_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_investor_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_investor_list) */ {
 public:
  req_investor_list();
  virtual ~req_investor_list();

  req_investor_list(const req_investor_list& from);

  inline req_investor_list& operator=(const req_investor_list& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_investor_list(req_investor_list&& from) noexcept
    : req_investor_list() {
    *this = ::std::move(from);
  }

  inline req_investor_list& operator=(req_investor_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_investor_list& default_instance();

  static inline const req_investor_list* internal_default_instance() {
    return reinterpret_cast<const req_investor_list*>(
               &_req_investor_list_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(req_investor_list* other);
  friend void swap(req_investor_list& a, req_investor_list& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_investor_list* New() const PROTOBUF_FINAL { return New(NULL); }

  req_investor_list* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_investor_list& from);
  void MergeFrom(const req_investor_list& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_investor_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string riskerid = 1;
  void clear_riskerid();
  static const int kRiskeridFieldNumber = 1;
  const ::std::string& riskerid() const;
  void set_riskerid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskerid(::std::string&& value);
  #endif
  void set_riskerid(const char* value);
  void set_riskerid(const char* value, size_t size);
  ::std::string* mutable_riskerid();
  ::std::string* release_riskerid();
  void set_allocated_riskerid(::std::string* riskerid);

  // @@protoc_insertion_point(class_scope:risk.req_investor_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr riskerid_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rsp_investor_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.rsp_investor_list) */ {
 public:
  rsp_investor_list();
  virtual ~rsp_investor_list();

  rsp_investor_list(const rsp_investor_list& from);

  inline rsp_investor_list& operator=(const rsp_investor_list& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rsp_investor_list(rsp_investor_list&& from) noexcept
    : rsp_investor_list() {
    *this = ::std::move(from);
  }

  inline rsp_investor_list& operator=(rsp_investor_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const rsp_investor_list& default_instance();

  static inline const rsp_investor_list* internal_default_instance() {
    return reinterpret_cast<const rsp_investor_list*>(
               &_rsp_investor_list_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(rsp_investor_list* other);
  friend void swap(rsp_investor_list& a, rsp_investor_list& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rsp_investor_list* New() const PROTOBUF_FINAL { return New(NULL); }

  rsp_investor_list* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const rsp_investor_list& from);
  void MergeFrom(const rsp_investor_list& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(rsp_investor_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string investorid = 2;
  void clear_investorid();
  static const int kInvestoridFieldNumber = 2;
  const ::std::string& investorid() const;
  void set_investorid(const ::std::string& value);
  #if LANG_CXX11
  void set_investorid(::std::string&& value);
  #endif
  void set_investorid(const char* value);
  void set_investorid(const char* value, size_t size);
  ::std::string* mutable_investorid();
  ::std::string* release_investorid();
  void set_allocated_investorid(::std::string* investorid);

  // .risk.error_info info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::risk::error_info& info() const;
  ::risk::error_info* mutable_info();
  ::risk::error_info* release_info();
  void set_allocated_info(::risk::error_info* info);

  // bool islast = 3;
  void clear_islast();
  static const int kIslastFieldNumber = 3;
  bool islast() const;
  void set_islast(bool value);

  // @@protoc_insertion_point(class_scope:risk.rsp_investor_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr investorid_;
  ::risk::error_info* info_;
  bool islast_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_margin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_margin) */ {
 public:
  subscribe_margin();
  virtual ~subscribe_margin();

  subscribe_margin(const subscribe_margin& from);

  inline subscribe_margin& operator=(const subscribe_margin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_margin(subscribe_margin&& from) noexcept
    : subscribe_margin() {
    *this = ::std::move(from);
  }

  inline subscribe_margin& operator=(subscribe_margin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_margin& default_instance();

  static inline const subscribe_margin* internal_default_instance() {
    return reinterpret_cast<const subscribe_margin*>(
               &_subscribe_margin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(subscribe_margin* other);
  friend void swap(subscribe_margin& a, subscribe_margin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_margin* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_margin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_margin& from);
  void MergeFrom(const subscribe_margin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_margin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.subscribe_margin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_margin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_margin) */ {
 public:
  unsubscribe_margin();
  virtual ~unsubscribe_margin();

  unsubscribe_margin(const unsubscribe_margin& from);

  inline unsubscribe_margin& operator=(const unsubscribe_margin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_margin(unsubscribe_margin&& from) noexcept
    : unsubscribe_margin() {
    *this = ::std::move(from);
  }

  inline unsubscribe_margin& operator=(unsubscribe_margin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_margin& default_instance();

  static inline const unsubscribe_margin* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_margin*>(
               &_unsubscribe_margin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(unsubscribe_margin* other);
  friend void swap(unsubscribe_margin& a, unsubscribe_margin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_margin* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_margin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_margin& from);
  void MergeFrom(const unsubscribe_margin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_margin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_margin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class shfe_margin_field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.shfe_margin_field) */ {
 public:
  shfe_margin_field();
  virtual ~shfe_margin_field();

  shfe_margin_field(const shfe_margin_field& from);

  inline shfe_margin_field& operator=(const shfe_margin_field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  shfe_margin_field(shfe_margin_field&& from) noexcept
    : shfe_margin_field() {
    *this = ::std::move(from);
  }

  inline shfe_margin_field& operator=(shfe_margin_field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const shfe_margin_field& default_instance();

  static inline const shfe_margin_field* internal_default_instance() {
    return reinterpret_cast<const shfe_margin_field*>(
               &_shfe_margin_field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(shfe_margin_field* other);
  friend void swap(shfe_margin_field& a, shfe_margin_field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline shfe_margin_field* New() const PROTOBUF_FINAL { return New(NULL); }

  shfe_margin_field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const shfe_margin_field& from);
  void MergeFrom(const shfe_margin_field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(shfe_margin_field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double pre_favorable = 1;
  void clear_pre_favorable();
  static const int kPreFavorableFieldNumber = 1;
  double pre_favorable() const;
  void set_pre_favorable(double value);

  // double big_side_favorable = 2;
  void clear_big_side_favorable();
  static const int kBigSideFavorableFieldNumber = 2;
  double big_side_favorable() const;
  void set_big_side_favorable(double value);

  // @@protoc_insertion_point(class_scope:risk.shfe_margin_field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double pre_favorable_;
  double big_side_favorable_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class cffex_margin_field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.cffex_margin_field) */ {
 public:
  cffex_margin_field();
  virtual ~cffex_margin_field();

  cffex_margin_field(const cffex_margin_field& from);

  inline cffex_margin_field& operator=(const cffex_margin_field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  cffex_margin_field(cffex_margin_field&& from) noexcept
    : cffex_margin_field() {
    *this = ::std::move(from);
  }

  inline cffex_margin_field& operator=(cffex_margin_field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const cffex_margin_field& default_instance();

  static inline const cffex_margin_field* internal_default_instance() {
    return reinterpret_cast<const cffex_margin_field*>(
               &_cffex_margin_field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(cffex_margin_field* other);
  friend void swap(cffex_margin_field& a, cffex_margin_field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline cffex_margin_field* New() const PROTOBUF_FINAL { return New(NULL); }

  cffex_margin_field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const cffex_margin_field& from);
  void MergeFrom(const cffex_margin_field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(cffex_margin_field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double pre_favorable = 1;
  void clear_pre_favorable();
  static const int kPreFavorableFieldNumber = 1;
  double pre_favorable() const;
  void set_pre_favorable(double value);

  // double speculation_favorable = 2;
  void clear_speculation_favorable();
  static const int kSpeculationFavorableFieldNumber = 2;
  double speculation_favorable() const;
  void set_speculation_favorable(double value);

  // double hedging_favorable = 3;
  void clear_hedging_favorable();
  static const int kHedgingFavorableFieldNumber = 3;
  double hedging_favorable() const;
  void set_hedging_favorable(double value);

  // double arbitrage_favorable = 4;
  void clear_arbitrage_favorable();
  static const int kArbitrageFavorableFieldNumber = 4;
  double arbitrage_favorable() const;
  void set_arbitrage_favorable(double value);

  // double market_favorable = 5;
  void clear_market_favorable();
  static const int kMarketFavorableFieldNumber = 5;
  double market_favorable() const;
  void set_market_favorable(double value);

  // @@protoc_insertion_point(class_scope:risk.cffex_margin_field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double pre_favorable_;
  double speculation_favorable_;
  double hedging_favorable_;
  double arbitrage_favorable_;
  double market_favorable_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dce_margin_field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.dce_margin_field) */ {
 public:
  dce_margin_field();
  virtual ~dce_margin_field();

  dce_margin_field(const dce_margin_field& from);

  inline dce_margin_field& operator=(const dce_margin_field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  dce_margin_field(dce_margin_field&& from) noexcept
    : dce_margin_field() {
    *this = ::std::move(from);
  }

  inline dce_margin_field& operator=(dce_margin_field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const dce_margin_field& default_instance();

  static inline const dce_margin_field* internal_default_instance() {
    return reinterpret_cast<const dce_margin_field*>(
               &_dce_margin_field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(dce_margin_field* other);
  friend void swap(dce_margin_field& a, dce_margin_field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline dce_margin_field* New() const PROTOBUF_FINAL { return New(NULL); }

  dce_margin_field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dce_margin_field& from);
  void MergeFrom(const dce_margin_field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dce_margin_field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double pre_favorable = 1;
  void clear_pre_favorable();
  static const int kPreFavorableFieldNumber = 1;
  double pre_favorable() const;
  void set_pre_favorable(double value);

  // double sp_favorable = 2;
  void clear_sp_favorable();
  static const int kSpFavorableFieldNumber = 2;
  double sp_favorable() const;
  void set_sp_favorable(double value);

  // double spc_favorable = 3;
  void clear_spc_favorable();
  static const int kSpcFavorableFieldNumber = 3;
  double spc_favorable() const;
  void set_spc_favorable(double value);

  // double locked_favorable = 4;
  void clear_locked_favorable();
  static const int kLockedFavorableFieldNumber = 4;
  double locked_favorable() const;
  void set_locked_favorable(double value);

  // @@protoc_insertion_point(class_scope:risk.dce_margin_field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double pre_favorable_;
  double sp_favorable_;
  double spc_favorable_;
  double locked_favorable_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class czce_margin_field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.czce_margin_field) */ {
 public:
  czce_margin_field();
  virtual ~czce_margin_field();

  czce_margin_field(const czce_margin_field& from);

  inline czce_margin_field& operator=(const czce_margin_field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  czce_margin_field(czce_margin_field&& from) noexcept
    : czce_margin_field() {
    *this = ::std::move(from);
  }

  inline czce_margin_field& operator=(czce_margin_field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const czce_margin_field& default_instance();

  static inline const czce_margin_field* internal_default_instance() {
    return reinterpret_cast<const czce_margin_field*>(
               &_czce_margin_field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(czce_margin_field* other);
  friend void swap(czce_margin_field& a, czce_margin_field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline czce_margin_field* New() const PROTOBUF_FINAL { return New(NULL); }

  czce_margin_field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const czce_margin_field& from);
  void MergeFrom(const czce_margin_field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(czce_margin_field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // double pre_favorable = 1;
  void clear_pre_favorable();
  static const int kPreFavorableFieldNumber = 1;
  double pre_favorable() const;
  void set_pre_favorable(double value);

  // double spd_favorable = 2;
  void clear_spd_favorable();
  static const int kSpdFavorableFieldNumber = 2;
  double spd_favorable() const;
  void set_spd_favorable(double value);

  // double ips_favorable = 3;
  void clear_ips_favorable();
  static const int kIpsFavorableFieldNumber = 3;
  double ips_favorable() const;
  void set_ips_favorable(double value);

  // double prt_favorable = 4;
  void clear_prt_favorable();
  static const int kPrtFavorableFieldNumber = 4;
  double prt_favorable() const;
  void set_prt_favorable(double value);

  // double std_favorable = 5;
  void clear_std_favorable();
  static const int kStdFavorableFieldNumber = 5;
  double std_favorable() const;
  void set_std_favorable(double value);

  // double stg_favorable = 6;
  void clear_stg_favorable();
  static const int kStgFavorableFieldNumber = 6;
  double stg_favorable() const;
  void set_stg_favorable(double value);

  // double zprt_favorable = 7;
  void clear_zprt_favorable();
  static const int kZprtFavorableFieldNumber = 7;
  double zprt_favorable() const;
  void set_zprt_favorable(double value);

  // double locked_favorable = 8;
  void clear_locked_favorable();
  static const int kLockedFavorableFieldNumber = 8;
  double locked_favorable() const;
  void set_locked_favorable(double value);

  // @@protoc_insertion_point(class_scope:risk.czce_margin_field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  double pre_favorable_;
  double spd_favorable_;
  double ips_favorable_;
  double prt_favorable_;
  double std_favorable_;
  double stg_favorable_;
  double zprt_favorable_;
  double locked_favorable_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rtn_margin_field : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.rtn_margin_field) */ {
 public:
  rtn_margin_field();
  virtual ~rtn_margin_field();

  rtn_margin_field(const rtn_margin_field& from);

  inline rtn_margin_field& operator=(const rtn_margin_field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rtn_margin_field(rtn_margin_field&& from) noexcept
    : rtn_margin_field() {
    *this = ::std::move(from);
  }

  inline rtn_margin_field& operator=(rtn_margin_field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const rtn_margin_field& default_instance();

  static inline const rtn_margin_field* internal_default_instance() {
    return reinterpret_cast<const rtn_margin_field*>(
               &_rtn_margin_field_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(rtn_margin_field* other);
  friend void swap(rtn_margin_field& a, rtn_margin_field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rtn_margin_field* New() const PROTOBUF_FINAL { return New(NULL); }

  rtn_margin_field* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const rtn_margin_field& from);
  void MergeFrom(const rtn_margin_field& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(rtn_margin_field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string investor = 2;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor() const;
  void set_investor(const ::std::string& value);
  #if LANG_CXX11
  void set_investor(::std::string&& value);
  #endif
  void set_investor(const char* value);
  void set_investor(const char* value, size_t size);
  ::std::string* mutable_investor();
  ::std::string* release_investor();
  void set_allocated_investor(::std::string* investor);

  // .risk.shfe_margin_field shfe_margin = 3;
  bool has_shfe_margin() const;
  void clear_shfe_margin();
  static const int kShfeMarginFieldNumber = 3;
  const ::risk::shfe_margin_field& shfe_margin() const;
  ::risk::shfe_margin_field* mutable_shfe_margin();
  ::risk::shfe_margin_field* release_shfe_margin();
  void set_allocated_shfe_margin(::risk::shfe_margin_field* shfe_margin);

  // .risk.cffex_margin_field cffex_margin = 4;
  bool has_cffex_margin() const;
  void clear_cffex_margin();
  static const int kCffexMarginFieldNumber = 4;
  const ::risk::cffex_margin_field& cffex_margin() const;
  ::risk::cffex_margin_field* mutable_cffex_margin();
  ::risk::cffex_margin_field* release_cffex_margin();
  void set_allocated_cffex_margin(::risk::cffex_margin_field* cffex_margin);

  // .risk.dce_margin_field dce_margin = 5;
  bool has_dce_margin() const;
  void clear_dce_margin();
  static const int kDceMarginFieldNumber = 5;
  const ::risk::dce_margin_field& dce_margin() const;
  ::risk::dce_margin_field* mutable_dce_margin();
  ::risk::dce_margin_field* release_dce_margin();
  void set_allocated_dce_margin(::risk::dce_margin_field* dce_margin);

  // .risk.czce_margin_field czce_margin = 6;
  bool has_czce_margin() const;
  void clear_czce_margin();
  static const int kCzceMarginFieldNumber = 6;
  const ::risk::czce_margin_field& czce_margin() const;
  ::risk::czce_margin_field* mutable_czce_margin();
  ::risk::czce_margin_field* release_czce_margin();
  void set_allocated_czce_margin(::risk::czce_margin_field* czce_margin);

  // uint32 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:risk.rtn_margin_field)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr investor_;
  ::risk::shfe_margin_field* shfe_margin_;
  ::risk::cffex_margin_field* cffex_margin_;
  ::risk::dce_margin_field* dce_margin_;
  ::risk::czce_margin_field* czce_margin_;
  ::google::protobuf::uint32 timestamp_;
  mutable int _cached_size_;
  friend struct protobuf_risk_5fprotocal_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// error_info

// sint32 errorid = 1;
inline void error_info::clear_errorid() {
  errorid_ = 0;
}
inline ::google::protobuf::int32 error_info::errorid() const {
  // @@protoc_insertion_point(field_get:risk.error_info.errorid)
  return errorid_;
}
inline void error_info::set_errorid(::google::protobuf::int32 value) {
  
  errorid_ = value;
  // @@protoc_insertion_point(field_set:risk.error_info.errorid)
}

// string errormsg = 2;
inline void error_info::clear_errormsg() {
  errormsg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& error_info::errormsg() const {
  // @@protoc_insertion_point(field_get:risk.error_info.errormsg)
  return errormsg_.GetNoArena();
}
inline void error_info::set_errormsg(const ::std::string& value) {
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.error_info.errormsg)
}
#if LANG_CXX11
inline void error_info::set_errormsg(::std::string&& value) {
  
  errormsg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.error_info.errormsg)
}
#endif
inline void error_info::set_errormsg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.error_info.errormsg)
}
inline void error_info::set_errormsg(const char* value, size_t size) {
  
  errormsg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.error_info.errormsg)
}
inline ::std::string* error_info::mutable_errormsg() {
  
  // @@protoc_insertion_point(field_mutable:risk.error_info.errormsg)
  return errormsg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* error_info::release_errormsg() {
  // @@protoc_insertion_point(field_release:risk.error_info.errormsg)
  
  return errormsg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void error_info::set_allocated_errormsg(::std::string* errormsg) {
  if (errormsg != NULL) {
    
  } else {
    
  }
  errormsg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), errormsg);
  // @@protoc_insertion_point(field_set_allocated:risk.error_info.errormsg)
}

// -------------------------------------------------------------------

// req_risker_login

// string riskerid = 1;
inline void req_risker_login::clear_riskerid() {
  riskerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_risker_login::riskerid() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_login.riskerid)
  return riskerid_.GetNoArena();
}
inline void req_risker_login::set_riskerid(const ::std::string& value) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_risker_login.riskerid)
}
#if LANG_CXX11
inline void req_risker_login::set_riskerid(::std::string&& value) {
  
  riskerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_risker_login.riskerid)
}
#endif
inline void req_risker_login::set_riskerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_risker_login.riskerid)
}
inline void req_risker_login::set_riskerid(const char* value, size_t size) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_risker_login.riskerid)
}
inline ::std::string* req_risker_login::mutable_riskerid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_risker_login.riskerid)
  return riskerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_risker_login::release_riskerid() {
  // @@protoc_insertion_point(field_release:risk.req_risker_login.riskerid)
  
  return riskerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_risker_login::set_allocated_riskerid(::std::string* riskerid) {
  if (riskerid != NULL) {
    
  } else {
    
  }
  riskerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskerid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_risker_login.riskerid)
}

// string password = 2;
inline void req_risker_login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_risker_login::password() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_login.password)
  return password_.GetNoArena();
}
inline void req_risker_login::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_risker_login.password)
}
#if LANG_CXX11
inline void req_risker_login::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_risker_login.password)
}
#endif
inline void req_risker_login::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_risker_login.password)
}
inline void req_risker_login::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_risker_login.password)
}
inline ::std::string* req_risker_login::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_risker_login.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_risker_login::release_password() {
  // @@protoc_insertion_point(field_release:risk.req_risker_login.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_risker_login::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:risk.req_risker_login.password)
}

// -------------------------------------------------------------------

// rsp_risker_login

// .risk.error_info info = 1;
inline bool rsp_risker_login::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void rsp_risker_login::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::risk::error_info& rsp_risker_login::info() const {
  const ::risk::error_info* p = info_;
  // @@protoc_insertion_point(field_get:risk.rsp_risker_login.info)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::error_info*>(
      &::risk::_error_info_default_instance_);
}
inline ::risk::error_info* rsp_risker_login::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::risk::error_info;
  }
  // @@protoc_insertion_point(field_mutable:risk.rsp_risker_login.info)
  return info_;
}
inline ::risk::error_info* rsp_risker_login::release_info() {
  // @@protoc_insertion_point(field_release:risk.rsp_risker_login.info)
  
  ::risk::error_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void rsp_risker_login::set_allocated_info(::risk::error_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rsp_risker_login.info)
}

// -------------------------------------------------------------------

// req_investor_list

// string riskerid = 1;
inline void req_investor_list::clear_riskerid() {
  riskerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_investor_list::riskerid() const {
  // @@protoc_insertion_point(field_get:risk.req_investor_list.riskerid)
  return riskerid_.GetNoArena();
}
inline void req_investor_list::set_riskerid(const ::std::string& value) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_investor_list.riskerid)
}
#if LANG_CXX11
inline void req_investor_list::set_riskerid(::std::string&& value) {
  
  riskerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_investor_list.riskerid)
}
#endif
inline void req_investor_list::set_riskerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_investor_list.riskerid)
}
inline void req_investor_list::set_riskerid(const char* value, size_t size) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_investor_list.riskerid)
}
inline ::std::string* req_investor_list::mutable_riskerid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_investor_list.riskerid)
  return riskerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_investor_list::release_riskerid() {
  // @@protoc_insertion_point(field_release:risk.req_investor_list.riskerid)
  
  return riskerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_investor_list::set_allocated_riskerid(::std::string* riskerid) {
  if (riskerid != NULL) {
    
  } else {
    
  }
  riskerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskerid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_investor_list.riskerid)
}

// -------------------------------------------------------------------

// rsp_investor_list

// .risk.error_info info = 1;
inline bool rsp_investor_list::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void rsp_investor_list::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) delete info_;
  info_ = NULL;
}
inline const ::risk::error_info& rsp_investor_list::info() const {
  const ::risk::error_info* p = info_;
  // @@protoc_insertion_point(field_get:risk.rsp_investor_list.info)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::error_info*>(
      &::risk::_error_info_default_instance_);
}
inline ::risk::error_info* rsp_investor_list::mutable_info() {
  
  if (info_ == NULL) {
    info_ = new ::risk::error_info;
  }
  // @@protoc_insertion_point(field_mutable:risk.rsp_investor_list.info)
  return info_;
}
inline ::risk::error_info* rsp_investor_list::release_info() {
  // @@protoc_insertion_point(field_release:risk.rsp_investor_list.info)
  
  ::risk::error_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline void rsp_investor_list::set_allocated_info(::risk::error_info* info) {
  delete info_;
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rsp_investor_list.info)
}

// string investorid = 2;
inline void rsp_investor_list::clear_investorid() {
  investorid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& rsp_investor_list::investorid() const {
  // @@protoc_insertion_point(field_get:risk.rsp_investor_list.investorid)
  return investorid_.GetNoArena();
}
inline void rsp_investor_list::set_investorid(const ::std::string& value) {
  
  investorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.rsp_investor_list.investorid)
}
#if LANG_CXX11
inline void rsp_investor_list::set_investorid(::std::string&& value) {
  
  investorid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.rsp_investor_list.investorid)
}
#endif
inline void rsp_investor_list::set_investorid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  investorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.rsp_investor_list.investorid)
}
inline void rsp_investor_list::set_investorid(const char* value, size_t size) {
  
  investorid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.rsp_investor_list.investorid)
}
inline ::std::string* rsp_investor_list::mutable_investorid() {
  
  // @@protoc_insertion_point(field_mutable:risk.rsp_investor_list.investorid)
  return investorid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rsp_investor_list::release_investorid() {
  // @@protoc_insertion_point(field_release:risk.rsp_investor_list.investorid)
  
  return investorid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rsp_investor_list::set_allocated_investorid(::std::string* investorid) {
  if (investorid != NULL) {
    
  } else {
    
  }
  investorid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), investorid);
  // @@protoc_insertion_point(field_set_allocated:risk.rsp_investor_list.investorid)
}

// bool islast = 3;
inline void rsp_investor_list::clear_islast() {
  islast_ = false;
}
inline bool rsp_investor_list::islast() const {
  // @@protoc_insertion_point(field_get:risk.rsp_investor_list.islast)
  return islast_;
}
inline void rsp_investor_list::set_islast(bool value) {
  
  islast_ = value;
  // @@protoc_insertion_point(field_set:risk.rsp_investor_list.islast)
}

// -------------------------------------------------------------------

// subscribe_margin

// repeated string investor = 1;
inline int subscribe_margin::investor_size() const {
  return investor_.size();
}
inline void subscribe_margin::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& subscribe_margin::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_margin.investor)
  return investor_.Get(index);
}
inline ::std::string* subscribe_margin::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_margin.investor)
  return investor_.Mutable(index);
}
inline void subscribe_margin::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_margin.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void subscribe_margin::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_margin.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void subscribe_margin::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.subscribe_margin.investor)
}
inline void subscribe_margin::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.subscribe_margin.investor)
}
inline ::std::string* subscribe_margin::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.subscribe_margin.investor)
  return investor_.Add();
}
inline void subscribe_margin::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.subscribe_margin.investor)
}
#if LANG_CXX11
inline void subscribe_margin::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.subscribe_margin.investor)
}
#endif
inline void subscribe_margin::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.subscribe_margin.investor)
}
inline void subscribe_margin::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.subscribe_margin.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
subscribe_margin::investor() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_margin.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
subscribe_margin::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_margin.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// unsubscribe_margin

// repeated string investor = 1;
inline int unsubscribe_margin::investor_size() const {
  return investor_.size();
}
inline void unsubscribe_margin::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& unsubscribe_margin::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_margin.investor)
  return investor_.Get(index);
}
inline ::std::string* unsubscribe_margin::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_margin.investor)
  return investor_.Mutable(index);
}
inline void unsubscribe_margin::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_margin.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_margin::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_margin.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_margin::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_margin.investor)
}
inline void unsubscribe_margin::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_margin.investor)
}
inline ::std::string* unsubscribe_margin::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_margin.investor)
  return investor_.Add();
}
inline void unsubscribe_margin::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_margin.investor)
}
#if LANG_CXX11
inline void unsubscribe_margin::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_margin.investor)
}
#endif
inline void unsubscribe_margin::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_margin.investor)
}
inline void unsubscribe_margin::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_margin.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_margin::investor() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_margin.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_margin::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_margin.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// shfe_margin_field

// double pre_favorable = 1;
inline void shfe_margin_field::clear_pre_favorable() {
  pre_favorable_ = 0;
}
inline double shfe_margin_field::pre_favorable() const {
  // @@protoc_insertion_point(field_get:risk.shfe_margin_field.pre_favorable)
  return pre_favorable_;
}
inline void shfe_margin_field::set_pre_favorable(double value) {
  
  pre_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.shfe_margin_field.pre_favorable)
}

// double big_side_favorable = 2;
inline void shfe_margin_field::clear_big_side_favorable() {
  big_side_favorable_ = 0;
}
inline double shfe_margin_field::big_side_favorable() const {
  // @@protoc_insertion_point(field_get:risk.shfe_margin_field.big_side_favorable)
  return big_side_favorable_;
}
inline void shfe_margin_field::set_big_side_favorable(double value) {
  
  big_side_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.shfe_margin_field.big_side_favorable)
}

// -------------------------------------------------------------------

// cffex_margin_field

// double pre_favorable = 1;
inline void cffex_margin_field::clear_pre_favorable() {
  pre_favorable_ = 0;
}
inline double cffex_margin_field::pre_favorable() const {
  // @@protoc_insertion_point(field_get:risk.cffex_margin_field.pre_favorable)
  return pre_favorable_;
}
inline void cffex_margin_field::set_pre_favorable(double value) {
  
  pre_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.cffex_margin_field.pre_favorable)
}

// double speculation_favorable = 2;
inline void cffex_margin_field::clear_speculation_favorable() {
  speculation_favorable_ = 0;
}
inline double cffex_margin_field::speculation_favorable() const {
  // @@protoc_insertion_point(field_get:risk.cffex_margin_field.speculation_favorable)
  return speculation_favorable_;
}
inline void cffex_margin_field::set_speculation_favorable(double value) {
  
  speculation_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.cffex_margin_field.speculation_favorable)
}

// double hedging_favorable = 3;
inline void cffex_margin_field::clear_hedging_favorable() {
  hedging_favorable_ = 0;
}
inline double cffex_margin_field::hedging_favorable() const {
  // @@protoc_insertion_point(field_get:risk.cffex_margin_field.hedging_favorable)
  return hedging_favorable_;
}
inline void cffex_margin_field::set_hedging_favorable(double value) {
  
  hedging_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.cffex_margin_field.hedging_favorable)
}

// double arbitrage_favorable = 4;
inline void cffex_margin_field::clear_arbitrage_favorable() {
  arbitrage_favorable_ = 0;
}
inline double cffex_margin_field::arbitrage_favorable() const {
  // @@protoc_insertion_point(field_get:risk.cffex_margin_field.arbitrage_favorable)
  return arbitrage_favorable_;
}
inline void cffex_margin_field::set_arbitrage_favorable(double value) {
  
  arbitrage_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.cffex_margin_field.arbitrage_favorable)
}

// double market_favorable = 5;
inline void cffex_margin_field::clear_market_favorable() {
  market_favorable_ = 0;
}
inline double cffex_margin_field::market_favorable() const {
  // @@protoc_insertion_point(field_get:risk.cffex_margin_field.market_favorable)
  return market_favorable_;
}
inline void cffex_margin_field::set_market_favorable(double value) {
  
  market_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.cffex_margin_field.market_favorable)
}

// -------------------------------------------------------------------

// dce_margin_field

// double pre_favorable = 1;
inline void dce_margin_field::clear_pre_favorable() {
  pre_favorable_ = 0;
}
inline double dce_margin_field::pre_favorable() const {
  // @@protoc_insertion_point(field_get:risk.dce_margin_field.pre_favorable)
  return pre_favorable_;
}
inline void dce_margin_field::set_pre_favorable(double value) {
  
  pre_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.dce_margin_field.pre_favorable)
}

// double sp_favorable = 2;
inline void dce_margin_field::clear_sp_favorable() {
  sp_favorable_ = 0;
}
inline double dce_margin_field::sp_favorable() const {
  // @@protoc_insertion_point(field_get:risk.dce_margin_field.sp_favorable)
  return sp_favorable_;
}
inline void dce_margin_field::set_sp_favorable(double value) {
  
  sp_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.dce_margin_field.sp_favorable)
}

// double spc_favorable = 3;
inline void dce_margin_field::clear_spc_favorable() {
  spc_favorable_ = 0;
}
inline double dce_margin_field::spc_favorable() const {
  // @@protoc_insertion_point(field_get:risk.dce_margin_field.spc_favorable)
  return spc_favorable_;
}
inline void dce_margin_field::set_spc_favorable(double value) {
  
  spc_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.dce_margin_field.spc_favorable)
}

// double locked_favorable = 4;
inline void dce_margin_field::clear_locked_favorable() {
  locked_favorable_ = 0;
}
inline double dce_margin_field::locked_favorable() const {
  // @@protoc_insertion_point(field_get:risk.dce_margin_field.locked_favorable)
  return locked_favorable_;
}
inline void dce_margin_field::set_locked_favorable(double value) {
  
  locked_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.dce_margin_field.locked_favorable)
}

// -------------------------------------------------------------------

// czce_margin_field

// double pre_favorable = 1;
inline void czce_margin_field::clear_pre_favorable() {
  pre_favorable_ = 0;
}
inline double czce_margin_field::pre_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.pre_favorable)
  return pre_favorable_;
}
inline void czce_margin_field::set_pre_favorable(double value) {
  
  pre_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.pre_favorable)
}

// double spd_favorable = 2;
inline void czce_margin_field::clear_spd_favorable() {
  spd_favorable_ = 0;
}
inline double czce_margin_field::spd_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.spd_favorable)
  return spd_favorable_;
}
inline void czce_margin_field::set_spd_favorable(double value) {
  
  spd_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.spd_favorable)
}

// double ips_favorable = 3;
inline void czce_margin_field::clear_ips_favorable() {
  ips_favorable_ = 0;
}
inline double czce_margin_field::ips_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.ips_favorable)
  return ips_favorable_;
}
inline void czce_margin_field::set_ips_favorable(double value) {
  
  ips_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.ips_favorable)
}

// double prt_favorable = 4;
inline void czce_margin_field::clear_prt_favorable() {
  prt_favorable_ = 0;
}
inline double czce_margin_field::prt_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.prt_favorable)
  return prt_favorable_;
}
inline void czce_margin_field::set_prt_favorable(double value) {
  
  prt_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.prt_favorable)
}

// double std_favorable = 5;
inline void czce_margin_field::clear_std_favorable() {
  std_favorable_ = 0;
}
inline double czce_margin_field::std_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.std_favorable)
  return std_favorable_;
}
inline void czce_margin_field::set_std_favorable(double value) {
  
  std_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.std_favorable)
}

// double stg_favorable = 6;
inline void czce_margin_field::clear_stg_favorable() {
  stg_favorable_ = 0;
}
inline double czce_margin_field::stg_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.stg_favorable)
  return stg_favorable_;
}
inline void czce_margin_field::set_stg_favorable(double value) {
  
  stg_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.stg_favorable)
}

// double zprt_favorable = 7;
inline void czce_margin_field::clear_zprt_favorable() {
  zprt_favorable_ = 0;
}
inline double czce_margin_field::zprt_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.zprt_favorable)
  return zprt_favorable_;
}
inline void czce_margin_field::set_zprt_favorable(double value) {
  
  zprt_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.zprt_favorable)
}

// double locked_favorable = 8;
inline void czce_margin_field::clear_locked_favorable() {
  locked_favorable_ = 0;
}
inline double czce_margin_field::locked_favorable() const {
  // @@protoc_insertion_point(field_get:risk.czce_margin_field.locked_favorable)
  return locked_favorable_;
}
inline void czce_margin_field::set_locked_favorable(double value) {
  
  locked_favorable_ = value;
  // @@protoc_insertion_point(field_set:risk.czce_margin_field.locked_favorable)
}

// -------------------------------------------------------------------

// rtn_margin_field

// uint32 timestamp = 1;
inline void rtn_margin_field::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::google::protobuf::uint32 rtn_margin_field::timestamp() const {
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.timestamp)
  return timestamp_;
}
inline void rtn_margin_field::set_timestamp(::google::protobuf::uint32 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:risk.rtn_margin_field.timestamp)
}

// string investor = 2;
inline void rtn_margin_field::clear_investor() {
  investor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& rtn_margin_field::investor() const {
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.investor)
  return investor_.GetNoArena();
}
inline void rtn_margin_field::set_investor(const ::std::string& value) {
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.rtn_margin_field.investor)
}
#if LANG_CXX11
inline void rtn_margin_field::set_investor(::std::string&& value) {
  
  investor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.rtn_margin_field.investor)
}
#endif
inline void rtn_margin_field::set_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.rtn_margin_field.investor)
}
inline void rtn_margin_field::set_investor(const char* value, size_t size) {
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.rtn_margin_field.investor)
}
inline ::std::string* rtn_margin_field::mutable_investor() {
  
  // @@protoc_insertion_point(field_mutable:risk.rtn_margin_field.investor)
  return investor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rtn_margin_field::release_investor() {
  // @@protoc_insertion_point(field_release:risk.rtn_margin_field.investor)
  
  return investor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rtn_margin_field::set_allocated_investor(::std::string* investor) {
  if (investor != NULL) {
    
  } else {
    
  }
  investor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), investor);
  // @@protoc_insertion_point(field_set_allocated:risk.rtn_margin_field.investor)
}

// .risk.shfe_margin_field shfe_margin = 3;
inline bool rtn_margin_field::has_shfe_margin() const {
  return this != internal_default_instance() && shfe_margin_ != NULL;
}
inline void rtn_margin_field::clear_shfe_margin() {
  if (GetArenaNoVirtual() == NULL && shfe_margin_ != NULL) delete shfe_margin_;
  shfe_margin_ = NULL;
}
inline const ::risk::shfe_margin_field& rtn_margin_field::shfe_margin() const {
  const ::risk::shfe_margin_field* p = shfe_margin_;
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.shfe_margin)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::shfe_margin_field*>(
      &::risk::_shfe_margin_field_default_instance_);
}
inline ::risk::shfe_margin_field* rtn_margin_field::mutable_shfe_margin() {
  
  if (shfe_margin_ == NULL) {
    shfe_margin_ = new ::risk::shfe_margin_field;
  }
  // @@protoc_insertion_point(field_mutable:risk.rtn_margin_field.shfe_margin)
  return shfe_margin_;
}
inline ::risk::shfe_margin_field* rtn_margin_field::release_shfe_margin() {
  // @@protoc_insertion_point(field_release:risk.rtn_margin_field.shfe_margin)
  
  ::risk::shfe_margin_field* temp = shfe_margin_;
  shfe_margin_ = NULL;
  return temp;
}
inline void rtn_margin_field::set_allocated_shfe_margin(::risk::shfe_margin_field* shfe_margin) {
  delete shfe_margin_;
  shfe_margin_ = shfe_margin;
  if (shfe_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rtn_margin_field.shfe_margin)
}

// .risk.cffex_margin_field cffex_margin = 4;
inline bool rtn_margin_field::has_cffex_margin() const {
  return this != internal_default_instance() && cffex_margin_ != NULL;
}
inline void rtn_margin_field::clear_cffex_margin() {
  if (GetArenaNoVirtual() == NULL && cffex_margin_ != NULL) delete cffex_margin_;
  cffex_margin_ = NULL;
}
inline const ::risk::cffex_margin_field& rtn_margin_field::cffex_margin() const {
  const ::risk::cffex_margin_field* p = cffex_margin_;
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.cffex_margin)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::cffex_margin_field*>(
      &::risk::_cffex_margin_field_default_instance_);
}
inline ::risk::cffex_margin_field* rtn_margin_field::mutable_cffex_margin() {
  
  if (cffex_margin_ == NULL) {
    cffex_margin_ = new ::risk::cffex_margin_field;
  }
  // @@protoc_insertion_point(field_mutable:risk.rtn_margin_field.cffex_margin)
  return cffex_margin_;
}
inline ::risk::cffex_margin_field* rtn_margin_field::release_cffex_margin() {
  // @@protoc_insertion_point(field_release:risk.rtn_margin_field.cffex_margin)
  
  ::risk::cffex_margin_field* temp = cffex_margin_;
  cffex_margin_ = NULL;
  return temp;
}
inline void rtn_margin_field::set_allocated_cffex_margin(::risk::cffex_margin_field* cffex_margin) {
  delete cffex_margin_;
  cffex_margin_ = cffex_margin;
  if (cffex_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rtn_margin_field.cffex_margin)
}

// .risk.dce_margin_field dce_margin = 5;
inline bool rtn_margin_field::has_dce_margin() const {
  return this != internal_default_instance() && dce_margin_ != NULL;
}
inline void rtn_margin_field::clear_dce_margin() {
  if (GetArenaNoVirtual() == NULL && dce_margin_ != NULL) delete dce_margin_;
  dce_margin_ = NULL;
}
inline const ::risk::dce_margin_field& rtn_margin_field::dce_margin() const {
  const ::risk::dce_margin_field* p = dce_margin_;
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.dce_margin)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::dce_margin_field*>(
      &::risk::_dce_margin_field_default_instance_);
}
inline ::risk::dce_margin_field* rtn_margin_field::mutable_dce_margin() {
  
  if (dce_margin_ == NULL) {
    dce_margin_ = new ::risk::dce_margin_field;
  }
  // @@protoc_insertion_point(field_mutable:risk.rtn_margin_field.dce_margin)
  return dce_margin_;
}
inline ::risk::dce_margin_field* rtn_margin_field::release_dce_margin() {
  // @@protoc_insertion_point(field_release:risk.rtn_margin_field.dce_margin)
  
  ::risk::dce_margin_field* temp = dce_margin_;
  dce_margin_ = NULL;
  return temp;
}
inline void rtn_margin_field::set_allocated_dce_margin(::risk::dce_margin_field* dce_margin) {
  delete dce_margin_;
  dce_margin_ = dce_margin;
  if (dce_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rtn_margin_field.dce_margin)
}

// .risk.czce_margin_field czce_margin = 6;
inline bool rtn_margin_field::has_czce_margin() const {
  return this != internal_default_instance() && czce_margin_ != NULL;
}
inline void rtn_margin_field::clear_czce_margin() {
  if (GetArenaNoVirtual() == NULL && czce_margin_ != NULL) delete czce_margin_;
  czce_margin_ = NULL;
}
inline const ::risk::czce_margin_field& rtn_margin_field::czce_margin() const {
  const ::risk::czce_margin_field* p = czce_margin_;
  // @@protoc_insertion_point(field_get:risk.rtn_margin_field.czce_margin)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::czce_margin_field*>(
      &::risk::_czce_margin_field_default_instance_);
}
inline ::risk::czce_margin_field* rtn_margin_field::mutable_czce_margin() {
  
  if (czce_margin_ == NULL) {
    czce_margin_ = new ::risk::czce_margin_field;
  }
  // @@protoc_insertion_point(field_mutable:risk.rtn_margin_field.czce_margin)
  return czce_margin_;
}
inline ::risk::czce_margin_field* rtn_margin_field::release_czce_margin() {
  // @@protoc_insertion_point(field_release:risk.rtn_margin_field.czce_margin)
  
  ::risk::czce_margin_field* temp = czce_margin_;
  czce_margin_ = NULL;
  return temp;
}
inline void rtn_margin_field::set_allocated_czce_margin(::risk::czce_margin_field* czce_margin) {
  delete czce_margin_;
  czce_margin_ = czce_margin;
  if (czce_margin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.rtn_margin_field.czce_margin)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace risk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_risk_5fprotocal_2eproto__INCLUDED
